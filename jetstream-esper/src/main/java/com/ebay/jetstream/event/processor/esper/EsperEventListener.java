/*
Pulsar
Copyright (C) 2013-2015 eBay Software Foundation
Licensed under the GPL v2 license.  See LICENSE for full terms.
*/
package com.ebay.jetstream.event.processor.esper;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.ApplicationEvent;

import com.ebay.jestream.event.annotation.AnnotationConfiguration;
import com.ebay.jestream.event.annotation.AnnotationListener;
import com.ebay.jestream.event.annotation.StatementAnnotationInfo;
import com.ebay.jetstream.counter.LongCounter;
import com.ebay.jetstream.event.EventException;
import com.ebay.jetstream.event.EventSink;
import com.ebay.jetstream.event.JetstreamErrorCodes;
import com.ebay.jetstream.event.JetstreamEvent;
import com.ebay.jetstream.event.RetryEventCode;
import com.ebay.jetstream.event.advice.Advice;
import com.ebay.jetstream.event.support.AbstractEventSource;
import com.ebay.jetstream.xmlser.Hidden;
import com.ebay.jetstream.xmlser.XSerializable;
import com.espertech.esper.client.EPServiceProvider;
import com.espertech.esper.client.EPStatement;
import com.espertech.esper.client.EventBean;
import com.espertech.esper.client.StatementAwareUpdateListener;


public class EsperEventListener extends AbstractEventSource implements StatementAwareUpdateListener, XSerializable {

	private static final Logger LOGGER = LoggerFactory.getLogger("com.ebay.jetstream.event.processor.esper");

	public static void setSinkError(boolean status) {
		m_sinkError.set(status);
	}

	private final AtomicLong m_eventReceived = new AtomicLong(0);

	private final AtomicLong m_eventSent = new AtomicLong(0);
	private final LongCounter m_cloneFailedCounter = new LongCounter(); 

	protected static final EsperEventConverter DEFAULT_CONVERTER = new EsperWrappedEventConverter();
	private static final String LOGGING_COMPONENT_NAME = "EsperEventListener";
	
	public static boolean isSinkError() {
		if (m_propagateEventOnFailure.get()) {
			return getSinkError();
		}
		else
			return false;
	}

	public static void resetSinkError() {
		m_sinkError.set(false);
	}

	private final AtomicLong m_eventsDropped = new AtomicLong();

	private static AtomicBoolean m_propagateEventOnFailure = new AtomicBoolean(false); // If there is an exception thrown

	@Hidden
	public static boolean getSinkError() {
		return m_sinkError.get().booleanValue();
	}

	private EsperEventConverter m_eventConverter = DEFAULT_CONVERTER;

	public static ThreadLocal<Boolean> m_sinkError = new ThreadLocal<Boolean>();

	private Advice m_adviceListener = null;

	private final AtomicLong eventSentToAdviceListener = new AtomicLong();
	
	private Map<String, AnnotationConfiguration> annotationConfig = new HashMap<String, AnnotationConfiguration>();


	public Advice getAdviceListener() {
		return m_adviceListener;
	}

	/**
	 * @return the eventConverter
	 */
	public EsperEventConverter getEventConverter() {
		return m_eventConverter;
	}

	public AtomicLong getEventReceived() {
		return m_eventReceived;
	}

	public AtomicLong getEventsDropped() {
		return m_eventsDropped;
	}

	public AtomicLong getEventSent() {
		return m_eventSent;
	}

	// by any of the sink, drop
	// subsequent events generated by
	// EPL for the incoming event.

	/**
	 * @return the eventSentToAdviceListener
	 */
	public AtomicLong getEventSentToAdviceListener() {
		return eventSentToAdviceListener;
	}

	private void incrementEventDropped() {
		if (m_eventsDropped.incrementAndGet() <= 0) {
			m_eventsDropped.set(0);
		}
	}

	private void incrementEventSentToAdviceListener() {
		if (eventSentToAdviceListener.incrementAndGet() < 0) {
			eventSentToAdviceListener.set(0);
		}
	}

	private void incrementEventsSent() {
		if (m_eventSent.incrementAndGet() <= 0) {
			m_eventSent.set(0);
		}
	}

	public boolean isPropagateEventOnFailure() {
		return m_propagateEventOnFailure.get();
	}

	@Override
	public void pause() {
		// TODO Auto-generated method stub

	}

	@Override
	protected void processApplicationEvent(ApplicationEvent event) {
		// TODO Auto-generated method stub

	}

	@Override
	public void resume() {
		// TODO Auto-generated method stub

	}

	private void sendToRetryQueue(JetstreamEvent event) {
		m_adviceListener.retry(event, RetryEventCode.PAUSE_RETRY, this.getClass().getSimpleName() + " IS PAUSED");
		incrementEventSentToAdviceListener();
	}

	public void setAdviceListener(Advice adviceListener) {
		m_adviceListener = adviceListener;
	}

	/**
	 * @param eventConverter
	 *          the eventConverter to set
	 */
	public void setEventConverter(EsperEventConverter eventConverter) {
		m_eventConverter = eventConverter == null ? DEFAULT_CONVERTER : eventConverter;
	}

	public void setPropagateEventOnFailure(boolean propagateEventOnFailure) {
		m_propagateEventOnFailure.set(propagateEventOnFailure);
	}

	protected void fireSendEvent(JetstreamEvent event) throws EventException {

		if (LOGGER.isDebugEnabled())
			event.log(this);

		JetstreamEvent fwdEvent = event;

		EventSink[] aSinks = (EventSink[])event.remove("sink.array");
		if (aSinks != null) {
			for (EventSink sink : aSinks) {

				// BUG FIX - SRM (1/14/2014) - every event has to be cloned as there is a chance that same event might 
				// be annotated differently in multiple statements


				try {
					fwdEvent = event.clone();

					if (fwdEvent == null)
						m_cloneFailedCounter.increment();

				} catch (CloneNotSupportedException e) {
					m_cloneFailedCounter.increment();
					LOGGER.error(
							"unable to clone event : "
							+ e.getLocalizedMessage());

					fwdEvent = null;
				}
				

				if (fwdEvent != null)
					sink.sendEvent(fwdEvent);

			}
		}
		else {
			Collection<EventSink> sinks = getEventSinks();
			if (sinks.size() <= 0 && getPausedEventSink().size() > 0)
				throw new EventException("All Event Sinks are  paused.....", JetstreamErrorCodes.EVENT_SINKS_PAUSED.toString());
			for (EventSink sink : sinks) {
				sink.sendEvent(event);
			}
		}
	}

	public void update(EventBean[] newEvents, EventBean[] oldEvents, EPStatement statement,
			EPServiceProvider service) {
		
		if(newEvents == null)
			return;

		m_eventReceived.incrementAndGet();
		
		if (isSinkError())
			return;
	
		EsperEventConverter converter = getEventConverter();
		for (EventBean bean : newEvents) {
			try {
				
				JetstreamEvent jetstreamEvent = converter.getJetstreamEvent(bean);
				
				if (jetstreamEvent == null) {
					if (LOGGER.isWarnEnabled()) {
						LOGGER.warn( "Ignoring event of type " + bean.getEventType() + ": " + bean);
								
					}
				}
				else {
					if (LOGGER.isDebugEnabled()) {
						LOGGER.debug("Received event: " + jetstreamEvent);
					}
					try {
						
						if (statement != null) {
							StatementAnnotationInfo info = (StatementAnnotationInfo)statement.getUserObject();
							if (info != null) {
								List<String> keys = info.getAnnotationInfoKeyList();
								for(int i = 0, t = keys.size(); i < t; i++){
									  AnnotationListener listener = annotationConfig.get(keys.get(i)).getListener();
									  listener.processMetaInformation(jetstreamEvent, info);
								}
							}
						}
						fireSendEvent(jetstreamEvent);
						incrementEventsSent();
					}
					catch (EventException e) {
						LOGGER.error( e.getLocalizedMessage() , e);

						if (e.getErrorCode() != null
								&& (e.getErrorCode().equalsIgnoreCase(JetstreamErrorCodes.EVENT_SINK_PAUSED.toString()) || e
										.getErrorCode().equalsIgnoreCase(JetstreamErrorCodes.EVENT_SINKS_PAUSED.toString()))) {
							if (m_adviceListener != null) {
								sendToRetryQueue(jetstreamEvent);
							}
							else {
								incrementEventDropped();
							}
						}
						else {
							incrementEventDropped();
						}
					}
				}
			}
			catch (EventException e) {
				setSinkError(true);
				LOGGER.error( e.getLocalizedMessage(), e);
				LOGGER.error(
						"Exception thrown from Sink. Setting sinkError to true. Events will not be passed to remaining sinks",
						e);
			}
		}
	}

	public Map<String, AnnotationConfiguration> getAnnotationConfig() {
		return annotationConfig;
	}

	public void setAnnotationConfig(
			Map<String, AnnotationConfiguration> annotationConfig) {
		this.annotationConfig = annotationConfig;
	}

	
}
